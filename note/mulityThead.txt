	自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，他们只要需要等一等（自旋），等持有锁的线程释放锁之后即可立即获取锁，这样就避免用户线程和内核切换的消耗。

	但是线程自旋是需要消耗cpu的，说白了就是让cpu做无用功，如果一直获取不到锁，那线程也不能一直占用cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。
	
	自旋锁尽可能的减少线程的阻塞，这对于所的竞争不激烈，且占用锁的时间非常短的代码块来说性能能大幅度提升，因为自旋的消耗会小鱼线程阻塞挂起再还清的操作的消耗，这些操作会导致线程发生两次上下文切换
	如果锁的竞争激烈，或者持有锁的线程㤇长时间占用锁执行同步块
	
	
	111111111
